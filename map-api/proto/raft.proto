package map_api.proto;
import "chunk.proto";
import "core.proto";
import "id.proto";

message RaftLogEntry {
  optional uint64 index = 1;
  optional uint64 term = 2;
  optional string sender = 3;
  optional uint64 sender_serial_id = 4;
  // TODO(aqurai): Are seperate fields for insert/update needed? They are
  // modified before sending, and can simply be patched on reception.
  optional Revision insert_revision = 5;
  optional Revision update_revision = 6;
  optional string add_peer = 7;
  optional string remove_peer = 8;
  optional string lock_peer = 9;
  optional string unlock_peer = 10;
  optional bool unlock_proceed_commits = 11;
  optional uint64 unlock_lock_index = 12;
  optional common.proto.Id revision_id = 13;
  optional uint64 logical_time = 14;
}

message AppendEntriesRequest {
  optional ChunkRequestMetadata metadata = 1;
  optional uint64 term = 2;
  optional uint64 last_log_index = 3;
  optional uint64 last_log_term = 4;
  optional uint64 commit_index = 5;
  optional uint64 previous_log_index = 6;
  optional uint64 previous_log_term = 7;
  optional RaftLogEntry log_entry = 8;
}

enum AppendResponseStatus {
  FAILED = 0;
  REJECTED = 1;
  ALREADY_PRESENT = 2;
  SUCCESS = 3;
}

message AppendEntriesResponse {
  optional uint64 term = 1;
  optional uint64 last_log_index = 2;
  optional uint64 last_log_term = 3;
  optional uint64 commit_index = 4;
  optional AppendResponseStatus response = 5;
}

message VoteRequest {
  optional ChunkRequestMetadata metadata = 1;
  optional uint64 term = 2;
  optional uint64 last_log_index = 3;
  optional uint64 last_log_term = 4;
  optional uint64 commit_index = 5;
}

enum VoteResponseType {GRANTED = 0; DECLINED = 1; VOTER_NOT_ELIGIBLE = 2;}

message VoteResponse {
  optional VoteResponseType vote = 1;
  optional uint64 previous_log_index = 2;
  optional uint64 previous_log_term = 3;
}

message QueryState {
  optional ChunkRequestMetadata metadata = 1;
}

message QueryStateResponse {
  optional string leader_id_ = 1;
  optional uint64 last_log_index = 3;
  optional uint64 last_log_term = 4;
  optional uint64 commit_index = 5;
  optional uint64 commit_result = 6;
}

message ConnectResponse {
  optional uint64 index = 1;
  optional string leader_id = 2;
}

message NewPeerInit {
  optional ChunkRequestMetadata metadata = 1;
  repeated string peer_id = 2;
  repeated RaftLogEntry log_entries = 3;
}

message InsertRequest {
  optional ChunkRequestMetadata metadata = 1;
  optional uint64 serial_id = 2;
  optional bool is_retry_attempt = 3;
  optional Revision revision = 4;
}

message LockRequest {
  optional ChunkRequestMetadata metadata = 1;
  optional uint64 serial_id = 2;
  optional bool is_retry_attempt = 3;
}

message UnlockRequest {
  optional ChunkRequestMetadata metadata = 1;
  optional uint64 serial_id = 2;
  optional bool is_retry_attempt = 3;
  optional uint64 lock_entry_index = 4;
  optional bool proceed_commits = 5;
}

message RaftLeaveRequest {
  optional ChunkRequestMetadata metadata = 1;
  optional uint64 serial_id = 2;
  optional bool is_retry_attempt = 3;
}

enum RaftChunkResponse {APPEND_SUCCESS = 0; APPENDED_BUT_FAILED = 1; REFUSED = 2;}

message RaftChunkRequestResponse {
  optional uint64 entry_index = 1;
  optional uint64 append_term = 2;
  optional RaftChunkResponse response_status =3;
}