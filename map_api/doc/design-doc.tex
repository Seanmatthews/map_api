\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{todonotes}
\usepackage{a4wide}

\title{Map API design document}
\author{Titus Cieslewski}
\date{Spring 2014}

\setlength{\parindent}{0mm}
%\setlength{\parskip}{3mm}

\begin{document}

\maketitle

\section{Overview}

The Map API should provide a mean for robots to collaborate on maps on a large
scale. It is designed with collaboration on a pose graph in mind, but pose
graph and the backend are separated, allowing using the Map API for other
map-related tasks.

The envisioned long-term goal is to develop a Peer-to-peer database system
(PDBS) geared towards mapping purposes.

\section{Application-to-database mapping, CR tables}

Applications acces the Map API by extending a table interface class. What
fields the application would want to use is to be defined in the virutal
method {\tt define()}, using calls to {\tt addField()}. \todo{tcies:
specify involved transactions}

Two types of table interfaces can be chosen: Table interfaces that allow
updating items (CRU tables) and table interfaces that don't (CR tables). 
Both expose the following protected methods:

\begin{itemize} \itemsep0em
  \item {\tt std::shared\_ptr$<$Revision$>$ getTemplate()}
  \item {\tt std::shared\_ptr$<$Revision$>$ getRow(const map\_api::Hash \&id)}
  \item {\tt map\_api::Hash insertQuery(Revision\& query)}
\end{itemize}

Objects are inserted into the database by first calling {\tt getTemplate()},
populating the obtained template revision with the data to be inserted, then 
sending
the filled revision to {\tt insertQuery()}. The function returns a look-up
hash which can be then used to retrieve the data from the database again by
suppying the hash to {\tt getRow()}.

\subsection{Structure of a {\tt map\_api::Revision}}

A revision object is an extended protocol buffer message which contains the
name of the table that the object belongs to and repeated key-type-value
triples. These contain the field information of the row represented by the
revision.

\subsection{Default fields}

All tables have per default two fields: ID and owner, both of which are
currently 128 bit hashes stored in string form. ID's are the primary key and
thus need to be unique. Per default, they are MD5 digests of the other fields
at insert-time.

\section{Tables with update-ability: CRU tables}

Tables with ability to update need to carry a revision history in order to be
able to perform meaningful transactions.

\subsection{Revision history}

Instead of containing the latest revision themselves, CRU table rows contain
a reference to their latest revision each. More precisely, the reference is to
an object with the following information:

\begin{itemize} \itemsep0em
  \item The ID of the corresponding CRU table row
  \item The revision
  \item A precise timpestamp of the revision
  \item A reference to the same object type, representing the previous revision
\end{itemize}

\todo{tcies: Ok, I see potential simplification here...}

In the implementation, these objects are stored in a revision history table
which is a CR table and has the same name as the table it versions, suffixed
with {\tt \_history}.

\section{Transactions}\label{transactions}

Queries to the Map API are handled by transactions, as previously specified in
the Map Manager API by St√©phane. The user can choose to make queries one by one
or to bundle them into transactions. In the former case the query is
automatically wrapped in a transaction, just like in SQL. \todo{tcies: Respec 
this in new pull request, too many changes (insert queries above and all...)}

\subsection{Transaction walkthrough}

\begin{enumerate} \itemsep0em
  \item When a transaction is initialized, the timestamp is taken. This allows
    for the transaction to hold a view on the database as it is at this
    particular instant.
  \item Write queries to the API are queued, not journaled and executed as in 
    SQL. This reduces overhead in case of conflict. Read queries are executed
    directly, but the returned revisions are always the latest revisions before
    the transaction view timestamp.
  \item When the transaction is filed for commit, a global lock for the
    database is acquired \todo{tcies: per-item locks, deadlock prevention}
  \item All modified objects are checked for conflict. In case of conflict,
    the transaction is aborted, but the application may retrieve the queue of
    queries in order to handle the conflict and attempt to re-apply.
  \item If the conflict handler succeeds or there are no conflicts, the 
    queries are executed and the locks are released.
\end{enumerate}

\subsection{How different queries are treated in transactions}

\begin{itemize} \itemsep0em
  \item {\bf Insert queries} only lead to conflict if the assigned hash ID is
    already present in the local database. It is in general assumed that insert
    conflicts don't happen \todo{tcies: We probably should switch to 
    time-seeded randomized hashes}
  \item {\bf Read queries} always return the latest revision from before the
    beginning of the transaction. \todo{Way to notify about outdated data?}
  \item {\bf Update queries} When update queries are queued, the latest
    revision before the update is referenced. If there exists a later revision 
    at commit time, there is a conflict.
\end{itemize}

\end{document}
